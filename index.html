<!DOCTYPE html>
<html>
<head>
    <!--Import Google Icon Font-->
    <!--<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">-->
    <!--Import materialize.css-->
    <link type="text/css" rel="stylesheet" href="css/materialize.min.css" media="screen,projection"/>

    <!--Let browser know website is optimized for mobile-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <style>
        .info {
            float: right;
        }

        #app {
            float: left;
            width: 50%;
        }

        fieldset {
            width: 30%;
            height: 100%;
            float: left;
        }

    </style>
</head>

<body>
<h1>Finding the line of best fit</h1>
<div class="row">
    <div class="col">
        <div class="card-panel">
            <div class="row"><label for="beta_0">Intercept</label>
                <input type="number" id="beta_0" placeholder="Intercept" step="0.1" class="line-param" value="0.4"/>
            </div>
            <div class="row"><label for="beta_1">Slope</label>
                <input type="number" id="beta_1" placeholder="Slope" step="0.1" class="line-param" value="-.2"/>
            </div>
            <label>Show Squares</label>
            <div class="row">
                <div class="switch"><label>Off<input type="checkbox" id="toggle-squares" disabled/>
                    <span class="lever"></span>On</label></div>
            </div>
            <div class="row">
                <button id="solve" class="btn waves-effect waves-green">Solve</button>
            </div>
            <div class="row">
                <button id="new-data" class="btn waves-effect waves-orange deep-orange">New Dataset</button>
            </div>
        </div>
    </div>
    <div class="col">
        <div id="scatter" class="card-panel"></div>
    </div>
    <div class="col l3 m3 s12">
        <div class="card-panel" id="instructions">
            <h3>Instructions</h3>
            <p>Change the slope and intercept to try to fit the line to the data.</p>
            <p>When you think you've got it, click <em>Solve</em> to see how close you were to the least squares
                solution.</p>
            <p>To learn more about <em>Least Squares</em>, click the below.</p>
            <button id="next-button" class="btn waves-effect waves-teal teal white-text">Next</button>
        </div>
    </div>
</div>
<!--JavaScript at end of body for optimized loading-->
<script type="text/javascript" src="js/materialize.min.js"></script>
<script type="text/javascript" src="js/d3.js"></script>
<script type="text/javascript">

    var w = 400;
    var h = 400;
    var padding = 30;
    var axispadding = 10;
    var xMin = -10;
    var xMax = 10;
    var numDataPoints = 20;
    var sigma = 2;
    randomCoef = d3.randomUniform(-2, 2);

    // var lineParams = {beta_0: 2, beta_1: -.5}

    randomData = function (numDataPoints, beta_0 = 0, beta_1 = 1, sigma = window.sigma) {
        ds = [];
        var xdist = d3.randomUniform(xMin, xMax);
        var eps = d3.randomNormal(0, sigma);
        for (var i = 0; i < numDataPoints; i++) {
            var x = xdist();
            var y = beta_0 + (beta_1 * x) + eps()
            ds.push([x, y]);
        }
        return ds;
    };

    var ds = randomData(numDataPoints, randomCoef(), randomCoef(), 2);

    function getx(d) {
        return d[0];
    }

    function gety(d) {
        return d[1];
    }


    var xScale = d3.scaleLinear()
        .domain([d3.min(ds, getx), d3.max(ds, getx)])
        .range([padding + axispadding, w - padding]);

    var yScale = d3.scaleLinear()
        .domain([d3.min(ds, gety), d3.max(ds, gety)])
        .range([h - padding - axispadding, padding]);

    var xAxis = d3.axisBottom(xScale);

    var yAxis = d3.axisLeft(yScale);

    var svg = d3.select("#scatter")
        .append("svg")
        .attr("width", w)
        .attr("height", h);

    function pathFromParams(lineParams) {
        var xDomain = xScale.domain();
        return [[xDomain[0], lineParams.beta_0 + lineParams.beta_1 * xDomain[0]],
            [xDomain[1], lineParams.beta_0 + lineParams.beta_1 * xDomain[1]]]
    }

    // add the x-axis
    svg.append("g")
        .attr("class", "axis")
        .attr("transform", "translate(0," + (h - padding) + ")")
        .call(xAxis);

    // add the y-axis
    svg.append("g")
        .attr("class", "axis")
        .attr("transform", "translate(" + padding + ", 0)")
        .call(yAxis);

    svg.selectAll("circle")
        .data(ds)
        .enter()
        .append("circle")
        .attr("cx", function (d) {
            return xScale(getx(d))
        })
        .attr("cy", function (d) {
            return yScale(gety(d))
        })
        .attr("class", "data-point")
        .attr("r", 3);

    var line = d3.line()
        .x(function (d) {
            return xScale(getx(d));
        })
        .y(function (d) {
            return yScale(gety(d));
        });

    // draw the line
    svg.append("path")
        .datum(pathFromParams(getLineParams()))
        .attr("id", "line-of-best-fit")
        .attr("d", line)
        .attr("fill", "none")
        .attr("stroke-width", 2)
        .attr("stroke", "red")
        .attr("stroke-dasharray", 4);

    function getLineParams() {
        return {
            beta_0: parseFloat(d3.select('#beta_0').node().value),
            beta_1: parseFloat(d3.select('#beta_1').node().value)
        };
    }

    function updateLine() {
        var newParams = getLineParams();
        var newPath = pathFromParams(newParams);

        svg.select("#line-of-best-fit")
            .datum(newPath)
            .transition()
            .attr("d", line);
    }


    d3.selectAll('.line-param')
        .on("change", function () {
            updateLine();
            updateSquares();
        });

    function yHat(lineParams, x) {
        return lineParams.beta_0 + lineParams.beta_1 * x;
    }

    function squareWidth(d) {
        let lineParams = getLineParams();
        let x = getx(d);
        let y = gety(d);
        let yh = yHat(lineParams, x);
        return Math.abs(yScale(y) - yScale(yh))
    };

    function squareX(d) {
        let boundary = (xScale.domain()[1] + xScale.domain()[0]) / 2;
        let x = getx(d);
        if (x < boundary) {
            return xScale(x)
        }
        else {
            return xScale(x) - squareWidth(d)
        }
    }

    function leastSquares(dataset) {
        // finds the least squares solution
        let X = [];
        let Y = [];
        for (let i = 0; i < dataset.length; i++) {
            X.push(getx(dataset[i]));
            Y.push(gety(dataset[i]));
        }
        let X_bar = d3.mean(X);
        let Y_bar = d3.mean(Y);

        let Sxy = 0;
        let Sxx = 0;
        for (let i = 0; i < dataset.length; i++) {
            let d = dataset[i];
            Sxy += (getx(d) - X_bar) * (gety(d) - Y_bar);
            Sxx += (getx(d) - X_bar) ** 2;
        }

        let beta_1 = Sxy / Sxx;
        let beta_0 = Y_bar - beta_1 * X_bar;

        return {beta_0: beta_0, beta_1: beta_1}
    }

    function squareY(d) {
        let boundary = yHat(getLineParams(), getx(d));
        let y = gety(d);
        if (y > boundary) {
            return yScale(y)
        }
        else {
            return yScale(y) - squareWidth(d)
        }
    }

    // draw squares
    svg.selectAll("rect")
        .data(ds)
        .enter()
        .append("rect")
        .attr("x", squareX)
        .attr("y", squareY)
        .attr("height", squareWidth)
        .attr("width", squareWidth)
        .attr("fill", "#13294b")
        .attr("stroke", "#13294b")
        .attr("fill-opacity", 0.2)
        .attr("opacity", 0); // don't draw them till they're asked for.

    function updateSquares() {
        svg.selectAll("rect")
            .data(ds)
            .transition()
            .attr("x", squareX)
            .attr("y", squareY)
            .attr("height", squareWidth)
            .attr("width", squareWidth)
            .attr("fill", "#13294b")
            .attr("stroke", "#13294b")
            .attr("fill-opacity", 0.2);
    }

    function toggleSquares() {
        let toggle = d3.select("#toggle-squares")
            .property("checked");
        svg.selectAll("rect")
            .transition()
            .attr("opacity", function () {
                return toggle ? 1 : 0;
            })
    }

    d3.select('#toggle-squares')
        .on("change", function () {
            toggleSquares();
        })

    d3.select("#solve")
        .on("click", function () {
            let ls = leastSquares(ds);
            document.getElementById('beta_0').value = ls.beta_0;
            document.getElementById('beta_1').value = ls.beta_1;
            updateLine();
            updateSquares();
        });

    d3.select("#new-data")
        .on("click", function () {
                ds = randomData(numDataPoints, randomCoef(), randomCoef());
                svg.selectAll('circle')
                    .data(ds)
                    .transition()
                    .attr("cx", function (d) {
                        return xScale(getx(d))
                    })
                    .attr("cy", function (d) {
                        return yScale(gety(d))
                    })
                    .attr("class", "data-point")
                    .attr("r", 3);
                updateSquares();
            }
        );

    function nextSlide() {
        d3.select("#toggle-squares")
            .attr('disabled', null);

        d3.select("#instructions")
            .selectAll("p")
            .remove()
        d3.select("#instructions")
            .select("h3")
            .append("p")
            .text("hello testing")
        ;
    }

    d3.select("#next-button")
        .on("click", nextSlide);


</script>
</body>
</html>